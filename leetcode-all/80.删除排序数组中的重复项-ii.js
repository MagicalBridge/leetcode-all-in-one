/*
 * @lc app=leetcode.cn id=80 lang=javascript
 *
 * [80] 删除排序数组中的重复项 II
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
// 这道题目和 26 题目的是差不多的单数排序数组中会包含多个重复项
// 要求是将所有的重复项全部清空，而不是只清空一个。
// 第一种解法：删除多余的重复项
// 因为数组已经是排序的了，所以重复项都在数组的左边，题目要求也是不使用额外的空间复杂度
// 最简单的方法就是删除多余的重复项，对于数组中的每一个数字，若出现两个以上的重复项，就将多余的重复项
// 从数组列表中删除。
// 算法：
// 1、我们需要在遍历数组元素的同时删除重复项，那么我们需要在删除多余重复项的同时更新数组的索引，否则将访问到无效的元素或跳过需要访问的元素。
// 2、我们使用两个变量 i 是遍历数组的指针 count 是记录当前数字出现的次数，count的最小计数始终为1。
// 3、我们从索引1 开始 一次处理一个元素。
// 4、若当前元素与前一个元素相同。即n ums[i] = nums[i-1],则增加计数，count++,如果 count > 2,则说明遇到了多余的重复元素，
// 要从数组中删除它，由于我们知道这个元素的索引，可以使用一些api进行操作，由于删除了一个元素，所以我们的索引要-1。
// 5、若当前元素与前一个元素不相同,即 nums[i] 不等于 nums[i-1] 说明我们遇到了一个新的元素，则更新count = 1；
// 6、由于我们从数组中删除了所有多余的重复项，只保留了有效的元素，最后返回出数组的长度即可。



// 0725 看到贾考博老师的视频这里跟着他的思路写一下
// 首先说明, 这个p 和 i 都是从索引 2 开始的。
// 因为前两个元素即使是相同的也是符合题意的。
var removeDuplicates = function (nums) {
  // p 指向第一个无效的位置什么是无效的位置就拿 1 1 1 2 2 3  这个数组来说，因为数组已经排序了
  // 即使前两个是重复的也是有效的,所以这个p指向的是第一个我们需要更新的位置。
  // 就拿上面这个例子来说, 第三个 1 也就是索引为2的位置 就是无效的，也是需要做处理的位置
  // p = 2 i = 2 nums[2] === nums[0] 此时 不做变换 i++
  // p = 2 i = 3 nums[3] !== nums[0] 开始做变换操作 nums[3] 值覆盖num[2]的位置。
  // 此时数组变成了 [1 1 2 2 2 3 ] 同时 p 和 i 都 ++ 
  // p = 3 i = 4 nums[4] !== nums[1] 此时 nums[4] 覆盖 nums[3]位置 
  // 此时数组变成了 [1 1 2 2 2 3 ] 同时 p 和 i 都 ++
  // p = 4 i = 5 nums[5] !== nums[2] 此时 nums[5] 覆盖 nums[4]位置 
  // 此时数组变成了 [1 1 2 2 3 3 ] 同时 p++ i++ 
  // p = 5 i = 6 结束循环 返回 p 的值
  let p = 2;
  for (let i = 2; i < nums.length; i++) {
    // 如果当前的数字不等于p指向的位置-2
    if (nums[i] !== nums[p - 2]) {
      nums[p] = nums[i];
      p++;
    }
  }
  return p

};
// @lc code=end

